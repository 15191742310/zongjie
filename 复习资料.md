RAII

# c/c++

## 面向对象的基本思想

封装、继承、多态

### **封装**：

面向对象程序设计最基本的特性，把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。

### **继承**：

是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构.体现了由简单到复杂的认识过程.

private:

public:

protected:

### **多态**：

多态性是考虑在不同层次的类中，以及在同一类中，同名的成员函数之间的关系问题。函数的重载，运算符的重载，属于编译时的多态性。以虚基类为基础的运行时的多态性是面向对象程序设计的标志性特征,体现了类推和比喻的思想方法。

两种多态：

**编译时的多态**：通过函数的重载和运算符人的重载来实现

**运行时的多态**：运行时的多态是指再程序运行前无法根据函数名和参数来确定具体调用哪一个函数，必须在程序的执行过程中，根据执行的具体情况来动态的确定。**通过继承和虚函数来实现的**

## 动态内存管理、深浅拷贝

内存管理的基本要求是**“不重不漏”**，不重复的delete也不漏掉delete。重载new是有争议的。

### C：

申请内存的方式：

#### **栈区**：

1.生命周期随栈帧。栈帧结束，内存归还给操作系统，无需程序人员管理。

2.空间开辟的大小固定，申请数组时数组的大小必须指定。他内存在编译时期就已经分配好。

3.程序在运行时期不能进行内存申请。而这种情况在编程中又很常见。所以就需要动态内存管理。

#### **堆区**：

1.生命周期由程序人员管理。需要手动申请手动释放。且必须释放，否则就会造成内存泄露

2.开辟空间大小由程序人员指定，更灵活。空间分配在程序运行期间分配。

malloc解析：

该函数向内存申请一块连续可用的空间，并返回指向这块内存的指针。
如果开辟空间成功，则返回一个开辟好空间的指针
如果申请失败，则返回一个NULL指针，因此malloc的返回值一定要进行检查，如果返回NULL，在进行解引用，程序就会崩溃。
返回值的类型是void*，所以malloc开辟的空间并不知道里面应该存储什么类型的数据。具体使用时，就必须进行强转。
参数size由程序员指定，如果size=0,则malloc的行为则是未定义的。取决于编译器
malloc申请的空间必须释放，且只能释放一次，释放的空间和申请的空间需要一一对应。
free（)解析：

free用来释放动态开辟的内存，所谓的释放就是取消指针与内存的对应关系。
参数如果ptr指向的空间不是动态申请的。则free的结果就是未定义的。
如果ptr是NULL，则free什么也不做。

#### **Data区**：

（生存期为整个程序）

BSS：（未初始化的数据区）全局为初始化，静态未初始化数据

data segment: 全局初始化，静态初始化，文字常量

#### **Text区**：

存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。

### C++

#### 关键字new与delete

C++中使用new和delete两个关键字动态管理内存

```c++
new和delete  动态管理对象
new[]和delete[]  动态管理对象数组
```

C++内存管理的其他函数

```cpp
void * operator new(size_t size)
void * operator delete(size_t size)
void * operator new[](size_t size)
void * operator delete[](size_t size)
```

1.这些函数不是new和delete的函数重载
2.用法和malloc函数一样。他们只是分配空间，释放空间。不会调用构造和析构函数。实际上就是malloc的一层封装。
3.实际是为new 和delete准备的。负责调用malloc申请空间和抛异常

```cpp
new->operator new=malloc+抛异常（bad_alloc）
delete->operator deletec
```

new：1申请空间  2释放对象

delete：1析构对象 释放对象

**new做了两件事：**（new[N]和delete[N]同理）
调用operator new ,然后 operator new再调用malloc申请空间。
调用构造函数初始化

**delete 做了两件事**

调用析构函数清理对象
调用operator delete释放空间

#### delete与[]delete的区别

![image-20210430205827327](C:\Users\kaitian\AppData\Roaming\Typora\typora-user-images\image-20210430205827327.png)

new 和new[]对比，new[N]会在空间的头上多开四字节空间，用来保存对象的个数，该对象个数用来指示析构的时候，要析构多少次。

如果new []和new都用delete释放，要么new[]的指针就会从头部开始释放而头部四字节空间不属于动态管理的空间，你去释放了就会导致释放了不属于你管辖空间，程序就会报错。

### new、delete与malloc、free的区别

- new和delete是关键字，malloc/free是库函数
- new操作符在自由存储区分配空间，不一定是堆上，还有可能是静态存储区，具体是哪里，取决于operator new的实现细节。new甚至可以不为对象分配空间，但malloc申请必须是堆上
- 对数组进行处理时，C++中new[]/delete专门来处理，而mlloc都一视同仁。
- new可以调用malloc,但malloc不可以调用new

malloc/free只是动态分配空间，释放空间。而new和delete除了分配空间，还会调用构造函数和析构函数进行初始化和清理。
malloc/free需要手动计算类型大小并返回void*,new/delete自动计算大小，返回对应指针。
malloc申请失败会返回空指针，而new/delete失败会抛异常（bad_alloc）,这里不用if/else判断，需要用try/catch捕捉异常

malloc可以直观的重新分配内存，当内存不够时 ，可以调用realloc来重新申请空间。将数据拷贝过去并释放原来的空间，而new 没有这样的机制。

## STL

### STL概念

 STL是标准模板库（基于模板）

STL分为：**容器** **算法** **迭代器**容器和算法之间通过迭代器进行无缝连接。STL几乎所有代码都采用了模板类或者模板函数

**头文件**

<algorithm> 、<deque>、<functional>、<vector>、<list>、<map>、<memory>、<numeric>、<queue>、<stack>、<utility>

### **vector**

#### 特性：

（1）支持随机访问

（2）动态自动增长vector当插入新元素的时候如果空间不足，那么vector会重新申请更大的一块内存空间，将原来的数据拷贝到新空间，释放旧空间，再把元素插入新空间。(capation容量前十个每次增加一，后面的测试后每次增长有指数的趋势)

**由于每次增加的时候会开辟更大的空间把之前的数据一次拷贝到新空间因此有效使用resize会提高程序的效率**

API

#### 构造

```c++
template<typename T>
vector<T> v;              //采用模板实现类实现，默认构造函数
vector(v.begin(),v.end()) //将begin与end之间的元素拷贝给本身
vector(n,elem)            //构造函数将n个elem拷贝给本身
vector(const vector &vec) //拷贝构造函数
```

#### 赋值操作

```cpp
assign(v.begin,v.end)   //将begin与end区间数据拷贝赋值给本身
assign(n,elem)          //将n个emel赋值给本身
vector &operator=(const vector &vec)  //重载赋值操作
swap(vec);                            //将本身的值与vec交换
void text()
{
      int arr []= {1,2,3,4,5,6};
      vector<int> v1(arr,arr[sizeof(arr)/sizeof(arr[0])]);
    
      vector<int> v2;
      v2.assign(v1.begin(,v1.end()));
    
      vector<int> v3;
      v3=v2;
      
      v3.swap(v2);                   //原理是将两个指针的指向进行交换
}
```

#### 大小

```cpp
size();          //返回容器中的元素的个数
empty();         //判断容器是否为空
resize(int num); //重新指定容器的长度为num，若容器变长，则默认值填充新位置，若容器变短则删除末尾超出容器的元素被删除
capacity();      //容器的容量
reserver(int len);      //容器预留len个位置，预留位置不初始化不可访问
```

#### 数据存取操作

```c++
at(int index);  //返回索引index指向的数据，如果越界，抛出out_of_range异常
operator[];     //返回索引所指向的值，越界时直接报错
front();        //返回容器的第一个元素
banck();        //返回容器的最后一个元素
```

#### 插入与删除

```cpp
insert(const iterator pos,int cont ,int elem) //迭代器指向位置插入count个num
push_back();                 //尾插
pop_back();                  //尾删
erase(const iterator start,const iterator end); //删除迭代器start到end的值
erase(const iterator pos);    //删除迭代器指向的元素
clear();                      //清空容器
```

#### swap缩减空间  **牛逼了**

```cpp
void text()
{
    vector<int> v;
    for(int i = 0; i < 10000;i++)
    {
        v.push_back();
    }
    cout<< "size" <<v.size()<<endl;
    cout<<"capacity"<<v.capacity()<<endl;
    
    v.resize(10);                   //只改变size不改变容量
    
    cout<< "size" <<v.size()<<endl;
    cout<<"capacity"<<v.capacity()<<endl;   //空间还是10000
    
    //收缩空间
    vector<int> (v).swap(v);         //vextor<int> ()匿名对象用v去初始化  初始化完成之后用swqp交换   
    cout<< "size" <<v.size()<<endl;
    cout<<"capacity"<<v.capacity()<<endl;
    
    
}
```

resize()与reserve()区别

```txt
resize既分配了空间，也创建了对象，可以通过下标访问。当resize的大小

reserve只修改capacity大小，不修改size大小，resize既修改capacity大小，也修改size大小。

reserve是容器预留空间，但并不真正创建元素对象，在创建对象之前，不能引用容器内的元素，因此当加入新的元素时，需要用push_back()/insert()函数。

resize是改变容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。

再者，两个函数的形式是有区别的，reserve函数之后一个参数，即需要预留的容器的空间；resize函数可以有两个参数，第一个参数是容器新的大小，第二个参数是要加入容器中的新元素，如果这个参数被省略，那么就调用元素对象的默认构造函数。
```



# ***最后总结关联容器是基于树状结构的，而无序关联容器是基于数据结构哈希表的。***

## 设计模式

## 智能指针

# Linux

## 基础

## 网络

## 数据结构

